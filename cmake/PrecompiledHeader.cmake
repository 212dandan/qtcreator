# TODO: missing clang support
cmake_minimum_required(VERSION 2.8.9 FATAL_ERROR)

macro(set_precompiled_header target language precompiledHeader precompiledSource)
    set(${target}_PCH_LANGUAGE ${language}
        CACHE INTERNAL "Which language (C/CXX) using for PCH support"
    )
    set(${target}_PCH_HEADER ${precompiledHeader}
        CACHE INTERNAL "Precompiled Header filename"
    )
    if (MSVC)
        get_filename_component(pchHeaderBasename ${precompiledHeader} NAME_WE)
        get_pch_source_extension(${target} srcext)
        set(${precompiledSource} ${target}_pch.${srcext})
        set(${target}_PCH_SOURCE ${${precompiledSource}}
            CACHE INTERNAL "Precompiled source filename"
        )
        if (NOT EXISTS ${CMAKE_CURRENT_BINARY_DIR}/${${precompiledSource}})
            file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/${${precompiledSource}}
                "/* This file is autogenerated, do not edit! */\n"
                "#include \"${CMAKE_CURRENT_SOURCE_DIR}/${precompiledHeader}\"\n"
            )
        endif()
        add_custom_target(${target}_pch)
        add_custom_command(TARGET ${target}_pch POST_BUILD
            COMMAND ${CMAKE_COMMAND} -E touch_nocreate ${CMAKE_CURRENT_BINARY_DIR}/${${precompiledSource}}
            COMMENT "[${target}] Update precompiled source - done"
        )
    endif()
endmacro()

macro(add_precompiled_header target)
    if (MSVC)
        add_msvc_precompiled_header(${target})
    elseif (CMAKE_COMPILER_IS_GNUC OR CMAKE_COMPILER_IS_GNUCXX OR MINGW)
        add_gcc_precompiled_header(${target})
    endif()
    if (ARGN)
        use_precompiled_header(${target} ${target} "${ARGN}")
    endif()
endmacro()

macro(use_precompiled_header targetSelf targetBinary sources)
    if (NOT ${targetBinary}_PCH_BINARY_FILE)
        message(WARNING "[${targetSelf}] Precompiled binary from '${targetBinary}' does not exist")
        return()
    endif()
    message(STATUS "[${targetSelf}] Using precompiled binary from target '${targetBinary}'")
    if (MSVC)
        fix_msvc_pch_shared_problem(${targetSelf} ${targetBinary})
        use_msvc_precompiled_header(${targetBinary} "${sources}")
    elseif (CMAKE_COMPILER_IS_GNUC OR CMAKE_COMPILER_IS_GNUCXX OR MINGW)
        use_gcc_precompiled_header(${targetBinary} "${sources}")
    endif()
endmacro()

function(add_pch_library target)
    if (CMAKE_COMPILER_IS_GNUC OR CMAKE_COMPILER_IS_GNUCXX OR MINGW)
        get_pch_source_extension(${target} srcext)
        set(source ${CMAKE_CURRENT_BINARY_DIR}/${target}_pch_library.${srcext})
        if (NOT EXISTS ${source})
            file(WRITE ${source}
                "/* This file is autogenerated, do not edit! */\n"
                "enum ${target}_pch_library { do_nothing };\n"
            )
        endif()
    endif()
    add_library(${target} ${ARGN} ${source})
    set_target_properties(${target} PROPERTIES
        DEFINE_SYMBOL ""
    )
    if (MSVC)
        set_target_properties(${target} PROPERTIES
            LINKER_LANGUAGE "${${target}_PCH_LANGUAGE}"
        )
    endif()
endfunction()

function(add_pch_flags target flags)
    if (CMAKE_COMPILER_IS_GNUC OR CMAKE_COMPILER_IS_GNUCXX OR MINGW)
        set(${target}_PCH_FLAGS ${flags}
            CACHE INTERNAL "The prepend additional compile flags for Precompiled Header support"
        )
    endif()
endfunction()

function(fix_msvc_pch_shared_problem targetSelf targetBinary)
    if ("${targetSelf}" STREQUAL "${targetBinary}")
        return()
    endif()
    # NOTE: Dirty hack! until to find other way
    get_filename_component(pdbpath ${${targetBinary}_PCH_BINARY_FILE} PATH)
    get_target_property(targetCompileFlags ${targetSelf} COMPILE_FLAGS)
    if (targetCompileFlags)
        set(origCompileFlags ${targetCompileFlags})
    endif()
    set_target_properties(${targetSelf} PROPERTIES
        COMPILE_FLAGS "${origCompileFlags} /Fd\"${pdbpath}/${targetBinary}.pdb\""
    )
    #set(CMAKE_${${targetBinary}_PCH_LANGUAGE}_FLAGS "${CMAKE_${${targetBinary}_PCH_LANGUAGE}_FLAGS} /Fd\"${pdbpath}/${targetBinary}.pdb\"")
    string(REGEX REPLACE " /Fd<TARGET_PDB>" "" temp "${CMAKE_${${targetBinary}_PCH_LANGUAGE}_COMPILE_OBJECT}")
    set(CMAKE_${${targetBinary}_PCH_LANGUAGE}_COMPILE_OBJECT ${temp} PARENT_SCOPE)
endfunction()

function(use_msvc_precompiled_header target sources)
    foreach(src ${sources})
        set_source_files_properties(${src} PROPERTIES
            COMPILE_FLAGS "/Yu\"${${target}_PCH_BINARY_FILE}\" /FI\"${${target}_PCH_BINARY_FILE}\" /Fp\"${${target}_PCH_BINARY_FILE}\""
            OBJECT_DEPENDS "${${target}_PCH_BINARY_FILE}"
        )
    endforeach()
endfunction()

function(add_msvc_precompiled_header target)
    get_filename_component(pchBinaryBasename ${${target}_PCH_SOURCE} NAME_WE)
    set(${target}_PCH_BINARY_FILE "${CMAKE_CURRENT_BINARY_DIR}/${pchBinaryBasename}.pch"
        CACHE INTERNAL "The path of the precompiled binary"
    )
    message(STATUS "[${target}] Precompiled binary is \"${${target}_PCH_BINARY_FILE}\"")
    set_source_files_properties(${${target}_PCH_SOURCE} PROPERTIES
        COMPILE_FLAGS "/Yc\"${CMAKE_CURRENT_SOURCE_DIR}/${${target}_PCH_HEADER}\" /Fp\"${${target}_PCH_BINARY_FILE}\""
        OBJECT_OUTPUTS "${${target}_PCH_BINARY_FILE}"
    )
endfunction()

function(use_gcc_precompiled_header target sources)
    foreach(src ${sources})
        set_source_files_properties(${src} PROPERTIES
            COMPILE_FLAGS "-include \"${${target}_PCH_HEADER_FILE}\" -Winvalid-pch"
            OBJECT_DEPENDS "${${target}_PCH_HEADER_FILE}"
        )
    endforeach()
endfunction()

function(add_gcc_precompiled_header target)
    set(origPCHFilename ${CMAKE_CURRENT_SOURCE_DIR}/${${target}_PCH_HEADER})
    if (NOT EXISTS ${origPCHFilename})
        message(FATAL_ERROR "[${target}] \"${origPCHFilename}\" does not exist")
        return()
    else()
        message(STATUS "[${target}] Precompiled header is \"${origPCHFilename}\"")
        get_filename_component(pchHeaderPath ${origPCHFilename} PATH)
        if (NOT ${pchHeaderPath} STREQUAL ${CMAKE_CURRENT_SOURCE_DIR})
            set(pchSearchPath "-I\"${pchHeaderPath}\"")
            separate_arguments(pchSearchPath)
        endif()
    endif()
    get_filename_component(pchHeaderName ${${target}_PCH_HEADER} NAME)
    set(${target}_PCH_BINARY_FILE "${CMAKE_CURRENT_BINARY_DIR}/${pchHeaderName}.gch"
        CACHE INTERNAL "The path of the precompiled binary"
    )
    set(${target}_PCH_HEADER_FILE ${CMAKE_CURRENT_BINARY_DIR}/${pchHeaderName}
        CACHE INTERNAL "The path of the precompiled header"
    )
    add_custom_command(OUTPUT ${${target}_PCH_HEADER_FILE}
        COMMAND ${CMAKE_COMMAND} -E copy_if_different ${origPCHFilename} ${${target}_PCH_HEADER_FILE}
        DEPENDS ${origPCHFilename}
        COMMENT "[${target}] Update precompiled header - done"
    )
    if (${${target}_PCH_LANGUAGE} STREQUAL "CXX")
        set(pchGenerator -x c++-header -c ${${target}_PCH_HEADER_FILE} -o ${${target}_PCH_BINARY_FILE})
    else(${${target}_PCH_LANGUAGE} STREQUAL "C")
        set(pchGenerator -x c-header -c ${${target}_PCH_HEADER_FILE} -o ${${target}_PCH_BINARY_FILE})
    else()
        message(FATAL_ERROR "[${target}] Unknown language \"${${target}_PCH_LANGUAGE}\"")
        return()
    endif()
    get_gcc_compile_flags(${target} compileFlags)
    message(STATUS "[${target}] PCH compile flags is ${compileFlags}")
    add_custom_command(OUTPUT ${${target}_PCH_BINARY_FILE}
        COMMAND ${CMAKE_CXX_COMPILER} ${${target}_PCH_FLAGS} ${compileFlags} ${pchSearchPath} ${pchGenerator}
        DEPENDS ${${target}_PCH_HEADER_FILE}
        COMMENT "[${target}] Compile precompiled binary - done"
    )
    add_custom_target(${target}_pch
        DEPENDS ${${target}_PCH_HEADER_FILE} ${${target}_PCH_BINARY_FILE}
    )
    add_dependencies(${target} ${target}_pch)
    message(STATUS "[${target}] Precompiled binary is \"${${target}_PCH_BINARY_FILE}\"")
endfunction()

function(get_gcc_compile_flags target flagsVar)
    string(TOUPPER "${CMAKE_BUILD_TYPE}" config)
    set(language ${${target}_PCH_LANGUAGE})
    # Collect options from CMake language variables
    if (CMAKE_${language}_FLAGS)
        list(APPEND compileFlags ${CMAKE_${language}_FLAGS})
    endif()
    if (CMAKE_${language}_FLAGS_${config})
        list(APPEND compileFlags ${CMAKE_${language}_FLAGS_${config}})
    endif()
    # Add option from CMake target type variable
    get_target_property(targetType ${target} TYPE)
    # handle POSITION_INDEPENDENT_CODE property introduced with CMake 2.8.9 if policy CMP0018 is turned on
    cmake_policy(GET CMP0018 _PIC_Policy)
    # Honor the POSITION_INDEPENDENT_CODE target property
    get_target_property(targetPIC ${target} POSITION_INDEPENDENT_CODE)
    if (targetPIC)
        if (targetType STREQUAL "SHARED_LIBRARY")
            list(APPEND compileFlags ${CMAKE_${language}_COMPILE_OPTIONS_PIC})
        elseif (targetType STREQUAL "EXECUTABLE")
            list(APPEND compileFlags ${CMAKE_${language}_COMPILE_OPTIONS_PIE})
        endif()
    endif()
    # Platform specific flags
    if (APPLE)
        get_target_property(architectures ${target} OSX_ARCHITECTURES_${config})
        if (NOT architectures)
            get_target_property(architectures ${target} OSX_ARCHITECTURES)
        endif()
        foreach (arch ${architectures})
            list(APPEND compileFlags "-arch" "${arch}")
        endforeach()
        if (CMAKE_OSX_SYSROOT AND CMAKE_OSX_SYSROOT_DEFAULT AND CMAKE_${language}_HAS_ISYSROOT)
            if (NOT "${CMAKE_OSX_SYSROOT}" STREQUAL "${CMAKE_OSX_SYSROOT_DEFAULT}")
                list(APPEND compileFlags "-isysroot" "${CMAKE_OSX_SYSROOT}")
            endif()
        endif()
        if (CMAKE_OSX_DEPLOYMENT_TARGET AND CMAKE_${language}_OSX_DEPLOYMENT_TARGET_FLAG)
            list(APPEND compileFlags "${CMAKE_${language}_OSX_DEPLOYMENT_TARGET_FLAG} ${CMAKE_OSX_DEPLOYMENT_TARGET}")
        endif()
    endif()
    # Add current dir in the first order
    if (CMAKE_INCLUDE_CURRENT_DIR)
        list(APPEND compileFlags "-I\"${CMAKE_CURRENT_BINARY_DIR}\"")
        list(APPEND compileFlags "-I\"${CMAKE_CURRENT_SOURCE_DIR}\"")
    endif()
    # Add directory properties
    get_directory_property(defines COMPILE_DEFINITIONS)
    if (defines)
        foreach(item ${defines})
            list(APPEND compileFlags "-D${item}")
        endforeach()
    endif()
    get_directory_property(defines COMPILE_DEFINITIONS_${config})
    if (defines)
        foreach(item ${defines})
            list(APPEND compileFlags "-D${item}")
        endforeach()
    endif()
    get_directory_property(value ${target} INCLUDE_DIRECTORIES)
    if (value)
        foreach(item ${value})
            list(APPEND compileFlags "-I\"${item}\"")
        endforeach()
    endif()
    # Add target compile options
    get_target_property(targetflags ${target} COMPILE_FLAGS)
    if (targetflags)
        list(APPEND compileFlags ${targetflags})
    endif()
    # Add target compile definitions
    get_target_property(defines ${target} COMPILE_DEFINITIONS)
    if (defines)
        foreach(item ${defines})
            list(APPEND compileFlags "-D${item}")
        endforeach()
    endif()
    get_target_property(defines ${target} COMPILE_DEFINITIONS_${config})
    if (defines)
        foreach(item ${defines})
            list(APPEND compileFlags "-D${item}")
        endforeach()
    endif()
    # Add target include directories
    get_target_property(value ${target} INCLUDE_DIRECTORIES)
    if (value)
        foreach(item ${value})
            list(APPEND compileFlags "-I\"${item}\"")
        endforeach()
    endif()
    separate_arguments(compileFlags)
    set(${flagsVar} ${compileFlags} PARENT_SCOPE)
endfunction()

function(get_pch_source_extension target extVar)
    if ("${${target}_PCH_LANGUAGE}" STREQUAL "CXX")
        set(${extVar} cpp PARENT_SCOPE)
    elseif ("${${target}_PCH_LANGUAGE}" STREQUAL "C")
        set(${extVar} c PARENT_SCOPE)
    endif()
endfunction()
